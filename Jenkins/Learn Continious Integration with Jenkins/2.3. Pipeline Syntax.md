# Jenkinsfile 

# What is Jenkinsfile?

![image](https://user-images.githubusercontent.com/107522496/216024448-289ebf02-f6fc-478a-90f1-00393c22dcfc.png)

Normally, in Jenkins, we would create new jobs and configure them. However, instead of creating and configuring jobs using the Jenkins User Interface, Jenkinsfile allows us to write a file (in other words, script a build and its configuration in a file) named `Jenkinsfile`.

* Jenkinsfile is Pipeline as a Code (a scripted pipeline). 
* The Jenkinsfile is created in your repository. 

---

The first step is to create a Jenkinsfile in your repository. Call it `Jenkinsfile`.

![image](https://user-images.githubusercontent.com/107522496/216026142-a54e910b-cdcd-404c-bc82-eef3fa799bf3.png)

```jenkinsfile
pipeline {

    agent any

    stages {

        stage('Build') {

            steps {
               
            }
        }
    }
}
```

The above is a boilerplate for a Jenkisfile. 

---

![image](https://user-images.githubusercontent.com/107522496/216026775-ad748361-2409-4bb0-b7cd-b46e1daf8b87.png)

A Jenkinsfile can be written as a Scripted Pipeline or a Declarative Pipeline. 

---

# Scripted Pipeline

The Scripted Pipeline was the first syntax of `Jenkinsfile`. It allows you to write the whole configuration of the Jenkinsfile using groovy script. 

![image](https://user-images.githubusercontent.com/107522496/216028277-2b9cfc45-d0ec-4060-a9a2-258a272901ba.png)

This means the only structure that you have in a Scripted Pipeline is the above screenshot and inside of it you have groovy scripts and you can write the whole configuration here in a flexible manner as you wish so there is no predefined structure. However, for
people who know groovy syntax or who havent' worked with groovy, it can be a  little difficult to start with.

---

# Declarative Pipeline

![image](https://user-images.githubusercontent.com/107522496/216029830-24478da5-ef6e-4ecf-8cc8-6fe8365b3c2a.png)

This is why more recently and new type of pipeline was introduced called Declarative Pipeline. It is easier to get started with but it is not as powerful as the Scripted Pipeline. The reason why it is easier to get started with is because there is a predefined structure, which is ...

![image](https://user-images.githubusercontent.com/107522496/216026142-a54e910b-cdcd-404c-bc82-eef3fa799bf3.png)

This is basically pre-given structure that you have to follow but you don't have to think about how to script all of this, you just need to fill in the gaps in each section. 

---

# Required Fields of a Jenkinsfile


```
node {
    // groovy script 
}
```

is the same as:

```
pipeline {

    agent any
```

---


In a Declarative Pipeline, you declare that you are writing a: 
* `pipeline {` must be at the top (top-level)
* `agent` -  this means this buildwill run on any available Jenkins agent. An agent can be a node, it can be executors on that node and this is more relevant to when you have a Jenkins cluster so to say with master and slaves where you have Windows nodes and Linux nodes etc. For basic scripts we use `agent any`.

> The first two, `pipeline` and `agent any`, are required attributes. This means you always have to use them.

*  `stages` this is the next required attribute. This is where all the "work" happens. This contains all the different stages of the pipeline. 

```
stages {

        stage('Build') {

            steps {
               
            }
```

Within `stages`, you define the stage name, such as  `stage('Build') {`. Within `stages`, you can define as many `stage`/steps as you want. For example, 

![image](https://user-images.githubusercontent.com/107522496/216032691-a39c31fd-7173-40e4-84d3-bfa877f9e344.png)

```
pipeline {

    agent any

    stages {

        stage('Build') {

            steps {
               
            }
        }

        stage('Test') {

            steps {
               
            }
        }

        stage('Deploy') {

            steps {
               
            }
        }
    }
}
```

* `steps` : within `steps` goes the script that actually executes some command on the Jenkins server or Jenkins agent. For example:

![image](https://user-images.githubusercontent.com/107522496/216036888-2437b5a7-1647-4fc3-af4c-898e0ad4be30.png)

```
pipeline {

    agent any

    stages {

        stage('Build') {

            steps {
               echo 'Building the application'
            }
        }

        stage('Test') {

            steps {
               echo 'Testing the application'
            }
        }

        stage('Deploy') {

            steps {
               echo 'Deploying the application'
            }
        }
    }
}
```

This is now a valid Jenkinsfile. We can then save it in the repository. When we run this Jenkinsfile, it will echo out a couple of statements. 











---



![image](https://user-images.githubusercontent.com/107522496/216039008-7e9b6eb8-ed64-4ac1-9fd5-e1ef2e7b23ab.png)

![image](https://user-images.githubusercontent.com/107522496/216039166-6bd40e7c-0f08-4a68-b813-fb07cd35d529.png)

![image](https://user-images.githubusercontent.com/107522496/216039379-680f1626-409b-4dbf-99e2-fd897a492ba5.png)

Add the name and choose `Multibranch Pipeline`. Then click `OK`.

![image](https://user-images.githubusercontent.com/107522496/216052824-cd782f15-b1ee-4e70-92f8-959d8eee8951.png)

Scroll down to `Branch Sources` and `Add Source`. Add `GitHub` and its `Repository HTTPS URL` and the `Credentials`. 

![image](https://user-images.githubusercontent.com/107522496/216051772-32c18e75-c78f-4084-bcfc-572cac6a4df5.png)

In the `Behaviours` section, it is asking which branches we want to build. I will leave it as `Discover branches` and `All branches get the same properties`. Then click `Apply` and then `Save`.

![image](https://user-images.githubusercontent.com/107522496/216053487-f9e7799f-0398-45c2-acb5-9949405ceba2.png)

Then to run, click on `Scan Repository Log`.This scans all the branches for the Jenkinsfile. `Scheduled build for branch: main 
1 branches were processed` tells us the `main` branch was built. To check that out ...

![image](https://user-images.githubusercontent.com/107522496/216054125-09a90d42-46f4-447a-9f54-125f5f862ced.png)

click on `main`.

---

![image](https://user-images.githubusercontent.com/107522496/216054323-c5a79490-162d-4da7-b9de-2b6ee2432386.png)

We can see that the stages we defined in the Jenkinsfile. 

![image](https://user-images.githubusercontent.com/107522496/216054572-e206c4c4-8cfc-4586-bd60-531213a64f67.png)

If we click on the logs for each stage, it outputs what we echoed in the Jenkinsfile. 

---

![image](https://user-images.githubusercontent.com/107522496/216054850-c3fbe1c6-feef-425f-a5f2-b09f7585b588.png)

`Declarative: Checkout SCM 	Build` comes from the ...

![image](https://user-images.githubusercontent.com/107522496/216055034-9d26b489-9bb4-48d4-8f7e-0ccb63ac94fb.png)

... configuration. This implicitly defines the first stage of the pipeline which is checking out the code

---

Question: how is it configured so that my pipeline looks for the Jenkinsfile in this project? The below configures this setting (`Script Path`) so it looks for a file called Jenkinsfile .

![image](https://user-images.githubusercontent.com/107522496/216056109-43204b57-8b50-4bff-9f44-58c7844ec706.png)

This is all you need to do in order to configure a pipeline to build from Jenkins file. The rest of the configuration of individual steps of build pipeline will be done in a Jenkins file itself.
 

---

# Post Attribute in Jenkinsfile

Let's go back to the Jenkinsfile and see what attributes we can use to configure different parts of the build. The below is the basic syntax where we have the base construct inside stages where we defined three different stages:

```
pipeline {

    agent any

    stages {

        stage('Build') {

            steps {
               echo 'Building the application'
            }
        }

        stage('Test') {

            steps {
               echo 'Testing the application'
            }
        }

        stage('Deploy') {

            steps {
               echo 'Deploying the application'
            }
        }
    }
}
```
---

Another thing we can do in a `Jenkinsfile` is that at the end of it you can define post attribute. This means it executes some kind of logic/scripts after all the stages are done.

```
post {

}
```

Inside the `post` there are different conditions that you can execute. For example:

![image](https://user-images.githubusercontent.com/107522496/216070981-48b2cbdb-2976-4623-8bbd-d39e54974d60.png)

```
pipeline {

    agent any

    stages {

        stage('Build') {

            steps {
               echo 'Building the application'
            }
        }

        stage('Test') {

            steps {
               echo 'Testing the application'
            }
        }

        stage('Deploy') {

            steps {
               echo 'Deploying the application'
            }
        }
    }

    post {
        always {
            //
        }
    }
}
```

![image](https://user-images.githubusercontent.com/107522496/216076050-21564a8a-7321-49cf-bdaa-c7079d02d924.png)

* `always`: Using an `always` condition within `post` means that section will always be executed no matter if the buildwasa success or failed.  This could be something like sending an email out to the team about the build, whether it failed or was a success.
* `success`: This block runs only if the build was successful.
* `failure`: This block runs only if the build failed.

To generalize, in the `post` block, you define expressions of either build status or build status change. So, for example, if the last build change failed and now it's green agan, you can use that condition as well.

---

# Define Conditionals for Each Stage 

We can also define conditionals/expressions for each stage. To do this, we can add `when` expressions within the `stage` block ...  

![image](https://user-images.githubusercontent.com/107522496/216079856-e48c3670-ebfc-4ad9-9938-07262486efcb.png)


The active branch name in the build is always available in `Jenkinsfile` through an environmental variable that Jenkins provides which is called `BRANCH_NAME`. Can also write it as `env.BRANCH_NAME`. You can use this to check what the current branch that is being built, is.

If we wanted to check if the active branch name is 'dev', we can use:

```
when {
                expression {
                        env.BRANCH_NAME == 'dev'
                }
            }
```

---

So, 

```
steps {
               echo 'Testing the application'
            }
            
```

will only run when the active branch is 'dev'. If the current branch is not dev, it will skip the `step` block within the `stage('Test')` block.

---


Can also use AND, OR expressions with Conditionals, so, for example, 

```
stage('Test') {
            when {
                expression {
                        env.BRANCH_NAME == 'dev' || env.BRANCH_NAME == 'master'
                }
            }

            steps {
               echo 'Testing the application'
            }
        }
```

The testing stage will only run if the current branch is 'dev' or 'master'.

---

Another situation where we can use `when` `expressions` is you only want to build your application if there are code changes made in the project. For example, in the 'build' stage, we can do:

![image](https://user-images.githubusercontent.com/107522496/216083948-4057078e-17e5-4235-86f7-231f0697268e.png)

Here, we are defining a variable called `CODE_CHANGES` outside of the pipeline.

`CODE_CHANGES = getGitChanges()` - this will be a groovy script that checks whether there has been any changes made in the code and sets the value of a boolean, of `true` or `false`.

---

# Environmental Variables

By default, Jenkins provides so environmental variables, for example curret branch name is `BRANCH_NAME`. 


There's some othr stuff that you might need for the logic, for example, you want to know which build number the current build is so you can use it in your versioning.

To see the list of environmental variables, type `/env-vars.html/` to the end of the URL ... 

![image](https://user-images.githubusercontent.com/107522496/216088044-2c575d05-e511-49c9-b0d0-d0d48dee41d9.png)

`http://localhost:8080/env-vars.html/`

You can use these environmental variables in your Jenkinsfile. 

In addition to the ones that Jenkins provides, you can define your own environmental variables and this is also a common practice.

---

# Define Your Own Environmental Variables

In Jenkinsfile there is an attribute called `environment`. Whatever environmental variables you define under `agent`, will be available for all the stages that you have in the pipeline. For example, below I have defined a variable `NEW_VERSION` which is equals to '1.3.0'.

![image](https://user-images.githubusercontent.com/107522496/216089434-e5edec2c-70fc-4e69-9500-98d570826719.png)

---

This is how we could use it in a stage:

![image](https://user-images.githubusercontent.com/107522496/216090629-4a8fa7ae-4ee2-4aec-92cb-12b5d0e33498.png)

---

Another practical example of using environmental variable can be credentials. 

For example, you have a stage that deploys your newly built application to a development server. And for that stage, you need credentials of the development server to connect to it and to copy the newly built artifact.

So, once you have defined credentials in Jenkins, you can use that in the `Jenkinsfile`.

---

![image](https://user-images.githubusercontent.com/107522496/216093316-f47be8ef-15cd-4a29-bb28-445c2b9c77d8.png)

Here, I have defined the `SERVER_CREDENTIALS` which equals to `credentials('')`. Here, we are extracting the credentials from Jenkins. The way this workks is, `credentials()` is a function/method that binds the credentials that are defined in Jenkins to your environmental variable (in this case, `SERVER_CREDENTIALS`). 

To bind credentials to variables, need the `Credentials Binding` Plugin which makes it possible to use Jenkins credentials inside the Jenkeesfile.

`credentials()` as a parameter, it takes the ID or reference of the credentials in Jenkins. 

To set the credentials in Jenkins ...

![image](https://user-images.githubusercontent.com/107522496/216100949-4f710241-87f8-418a-9e7e-536338e71f1b.png)

Go to _Manage Jenkins_ > _Credentials_

---

![image](https://user-images.githubusercontent.com/107522496/216101565-7deec2fe-af73-46ae-aa1e-c028dd0382a1.png)

Click on `global` at the bottom  

---

![image](https://user-images.githubusercontent.com/107522496/216102215-5e31354a-64d4-46b4-ab2a-9f1b5f3f34a9.png)

Then click on _Add Credentials_

---

![image](https://user-images.githubusercontent.com/107522496/216102926-f08cec62-782a-4e14-bc7f-4d0c9ae55cac.png)

The kind for this example will be `Username with password`.

---

![image](https://user-images.githubusercontent.com/107522496/216102685-1c9ed8de-2c61-4ace-85ca-a118f17b13ed.png)

Add your username for the server and the password. `ID` is the reference for these credentials. Then click on `Create`.

We will now be able to reference these credentials in the Jenkinsfile via an environment variable using the `ID` (reference) we provided ...

![image](https://user-images.githubusercontent.com/107522496/216103665-5f48b827-1ba7-4eb2-bf74-d4595e141b7d.png)

---

We can then use that environmental variable within a stage the same way as we did with `NEW_VERSION`. We have to enclose it in double quotes ...

![image](https://user-images.githubusercontent.com/107522496/216104470-9d0b27c2-6191-4ff2-a07e-e2a2c60ee1ea.png)

---















































